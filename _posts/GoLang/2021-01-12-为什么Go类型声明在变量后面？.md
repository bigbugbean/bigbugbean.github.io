---
title: 为什么Go类型声明在变量后面？
tags: Golang
typora-copy-images-to: ..\..\assets\blog_img
typora-root-url: ..\..
---

> 本文翻译自[Go's Declaration Syntax](https://blog.golang.org/declaration-syntax)

#### 引言

刚学Go的人都会带有这样一个疑问，为什么Go的声明语法和传统的C家族不同，在这篇文章中，我们将比较这两种方法，并解释为什么Go的声明是这样的。

#### C的语法

首先，我们谈谈C的语法。C在声明语法方面采用了一种不同寻常且巧妙的方法。不用特殊的语法来描述类型，而是写一个包含被声明项的表达式，并声明该表达式将具有什么类型。看起来是这样的

```c
int x;
```

此代码的含义是：声明表达式x为int类型。通常，要确定如何编写新变量的类型，需要编写一个包含该变量的表达式，该变量的计算结果为基本类型，然后将基本类型放在左边，表达式放在右边。

因此，有如下声明

```c
int *p;
int a[3];
```

声明p是一个指向int的指针，因为'*p'的类型是int，而且a是一个整型数组，因为a[3]的类型是整型的。

那么函数是怎样定义的呢？最初，C的函数声明将参数的类型写在括号之外，如下所示：

```c
int main(argc, argv)
    int argc;
    char *argv[];
{ /* ... */ }
```

同样，我们看到main是一个函数，因为表达式main(argc, argv)返回一个int值。虽然用现代的语法可以表示为：

```c
int main(int argc, char *argv[]) { /* ... */ }
```

但基本结构是一样的。

这是一种巧妙的语法思想，适用于简单类型，但可能很快就会让人感到困惑。最著名的例子是声明函数指针。遵守规则，你会得到这个：

```c
int (*fp)(int a, int b);
```

这里，fp是一个指向函数的指针，因为如果您编写表达式(*fp)(a, b)，您将调用一个返回int的函数。那如果fp的一个参数本身就是一个函数呢?

```c
int (*fp)(int (*ff)(int x, int y), int b)
```

开始看不懂了。

当然，在声明函数时可以省去参数名，这样就可以把main声明成如下的样子：

```c
int main(int, char *[])
```

回想一下在没有省去参数名之前，argv是这样声明的，

```c
char *argv[]
```

因此，您可以从它的声明中间删除名称来构造它的类型。但是，通过将其名字放在中间来声明char *[]类型的某个变量，这一点并不明显。

看看如果你不命名参数fp的声明会发生什么:

```c
int (*fp)(int (*)(int, int), int)
```

不仅不清楚该把名字放在哪里

```c
int (*)(int, int)
```

它到底是不是一个函数指针声明还不是很清楚。如果返回类型是函数指针呢?

```c
int (*(*fp)(int (*)(int, int), int))(int, int)
```

甚至很难看出这个声明是关于fp的。

您可以构造更复杂的示例，但上面这些示例应该能够说明C声明语法带来的一些困难。

不过，还有一点需要说明。因为类型和声明语法是相同的，所以很难解析中间有类型的表达式。这就是为什么C类型转换总是用括号括起来的原因

```c
(int)M_PI
```

#### Go的语法

C家族以外的语言通常在声明中使用不同的类型语法。虽然这是一个分隔的点，但名字通常放在前面，后面通常有一个冒号。因此，我们上面的例子就变成了(用一种虚构但具有说明性的语言)

```
x: int
p: pointer to int
a: array[3] of int
```

这些声明是清晰的，但有些冗长——只需从左到右读取即可。Go从这里得到提示，但为了简洁起见，它去掉了冒号并删除了一些关键字：

```go
x int
p *int
a [3]int
```

[3]int的外观与如何在表达式中使用a之间没有直接对应关系。您将以分隔的语法为代价获得清晰性。

现在考虑函数的声明。让我们把main的声明抄写下来，就像在Go中读到的那样，尽管真正的main函数在Go中没有参数：

```go
func main(argc int, argv []string) int
```

从表面上看，这与C语言没有太大区别，只是从char数组改变为字符串，但它从左到右读起来的效果很好：

main函数接受一个int和一个字符串切片，然后返回一个int。

去掉参数名也一样清楚——它们总是排在第一个，这样就不会混淆了。

```go
func main(int, []string) int
```

这种从左到右的样式的一个优点是，当类型变得更复杂时，它的工作效果很好。下面是一个函数变量的声明(类似于C中的函数指针)：

```go
f func(func(int,int) int, int) int
```

或者如果f返回一个函数：

```go
f func(func(int,int) int, int) func(int, int) int
```

从左到右读起来仍然很清楚，而且声明的名字总是很明显——名字排在前面。

类型和表达式语法的区别使得在Go中编写和调用闭包很容易：

```go
sum := func(a, b int) int { return a+b } (3, 4)
```

#### 指针

指针是证明该规则的例外。注意，在数组和切片中，例如，Go的类型语法将中括号放在类型的左边，而表达式语法将中括号放在表达式的右边：

```go
var a []int
x = a[1]
```

为了熟悉起见，Go的指针使用了C中的*符号，但是我们不能让自己对指针类型进行类似的反转。因此指针是这样工作的

```go
var p *int
x = *p
```

我们不能说

```go
var p *int
x = p*
```

因为后缀*会和乘法符合混淆。我们本可以使用用Pascal的^符号，例如:

```go
var p ^int
x = p^
```

也许我们应该这样做(并为xor选择另一个操作符)，因为类型和表达式上的前缀星号在许多方面使事情变得复杂。例如，虽然可以这样写：

```go
[]int("hi")
```

作为转换，如果以*开头，则必须在类型后面加上括号：

```go
(*int)(nil)
```

如果我们愿意放弃*作为指针语法，那么这些括号就没有必要了。

因此，Go的指针语法与熟悉的C形式相关联，但是这些联系意味着我们无法完全摆脱使用括号消除语法中的类型和表达式的歧义。

不过，总的来说，我们认为Go的类型语法比C的语法更易于理解，尤其是当事情变得复杂时。

#### 说明

Go的声明是从左到右读取。有人指出，C的读法是螺旋形的！参见David Anderson的文章[The "Clockwise/Spiral Rule"](http://c-faq.com/decl/spiral.anderson.html)。